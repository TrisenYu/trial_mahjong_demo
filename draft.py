def convertor(val: int, lena: int = 9) -> list[int]:
	_res: list[int] = []
	while val:
		_res.append(val % 5)
		val //= 5
	while len(_res) != lena:
		_res.append(0)
	return _res

lena = pow(5, 9)
lenb = pow(5, 7)
ca, cb = 0, 0
ia, ib = 0, 0

for i in range(0, lena):
    arr = convertor(i)
    cnt = sum(arr)
    if 18 < cnt:
        ia += 1
        continue
print(lena, ia)

for i in range(0, lenb):
    arr = convertor(i, 7)
    cnt = sum(arr)
    if 18 < cnt:
        ib += 1
        continue
print(lenb, ib)

# 1,066,725 种合法可能合法情况，其中 46426 种可以直接构成 hu。53440 种可以构成可供转化的组件。966,859 种其它情况("如hu"、"孤牌")。
#    68,995 对字而言的可能合法情况。其中 7701 种可直接构成 hu。34995 种构成转换的中间部件，26299 种其它情况
"""
成为组件的，应该有 78 类？
组件可以从输入的单牌开始跳转。
总体上加不过 6.

78
# (s, p, t, q)
(2, 1, 0, 0)
(0, 0, 3, 1)
(0, 1, 2, 1)
(0, 1, 3, 0)
(0, 6, 0, 0)
(0, 1, 1, 2)
(0, 1, 0, 0)
(2, 2, 1, 0)
(1, 5, 0, 0)
(0, 2, 3, 0)
(1, 0, 3, 0)
(0, 2, 0, 1)
(2, 0, 0, 1)
(1, 0, 1, 0)
(0, 0, 2, 0)
(0, 5, 1, 0)
(1, 3, 0, 0)
(1, 1, 0, 1)
(0, 4, 0, 1)
(1, 4, 0, 0)
(0, 0, 4, 0)
(2, 0, 1, 1)
(2, 0, 2, 0)
(0, 3, 1, 0)
(1, 1, 2, 0)
(1, 2, 1, 0)
(0, 3, 0, 1)
(3, 1, 0, 0)
(2, 1, 1, 0)
(3, 2, 0, 0)
(1, 2, 0, 1)
(0, 1, 2, 0)
(0, 1, 1, 1)
(1, 1, 1, 0)
(0, 4, 1, 0)
(1, 0, 0, 1)
(0, 1, 0, 2)
(0, 2, 2, 0)
(1, 0, 2, 1)
(2, 0, 0, 0)
(0, 2, 1, 1)
(0, 0, 0, 2)
(0, 0, 1, 1)
(3, 0, 0, 1)
(3, 0, 1, 0)
(0, 0, 2, 1)
(0, 0, 3, 0)
(4, 0, 0, 0)
(0, 3, 0, 0)
(2, 1, 0, 1)
(1, 2, 0, 0)
(1, 2, 2, 0)
(0, 1, 1, 0)
(2, 2, 0, 0)
(0, 2, 0, 0)
(1, 0, 0, 0)
(0, 1, 0, 1)
(0, 5, 0, 0)
(1, 1, 0, 0)
(0, 4, 0, 0)
(1, 0, 2, 0)
(0, 2, 1, 0)
(1, 1, 1, 1)
(2, 0, 1, 0)
(0, 0, 0, 1)
(0, 2, 0, 2)
(0, 0, 1, 0)
(1, 0, 0, 2)
(1, 0, 1, 1)
(1, 3, 0, 1)
(1, 3, 1, 0)
(3, 0, 0, 0)
(1, 1, 0, 2)
(0, 3, 2, 0)
(0, 0, 0, 3)
(2, 3, 0, 0)
(0, 0, 1, 2)
(0, 3, 1, 1)
"""

"""
如果再细分，麻将是通过最开始无牌向孤牌，边张/嵌张/双边向顺子开始转移的

孤牌自身又可以转移到对子/边张/嵌张/双边上。
让一副牌编号实际上
"""

# 边张分布
# [(0, 0), 0, 0, 0, 0, 0, (0, 0)]
# 嵌张分布
# [0, 0, 0, 0, 0, 0, *, 0, *]
# [0, 0, 0, 0, 0, *, 0, *, 0]
# [0, 0, 0, 0, *, 0, *, 0, 0]
# [0, 0, 0, *, 0, *, 0, 0, 0]
# [0, 0, *, 0, *, 0, 0, 0, 0]
# [0, *, 0, *, 0, 0, 0, 0, 0]
# [*, 0, *, 0, 0, 0, 0, 0, 0]
# 双边 分布
# [0, *, *, 0, 0, 0, 0, 0, 0]
# [0, 0, *, *, 0, 0, 0, 0, 0]
# [0, 0, 0, *, *, 0, 0, 0, 0]
# [0, 0, 0, 0, *, *, 0, 0, 0]
# [0, 0, 0, 0, 0, *, *, 0, 0]
# [0, 0, 0, 0, 0, 0, *, *, 0]

# 对于单副牌，应该分开维护 4 个状态自动机。4 个状态自动机来抢占胡牌状态？感觉不够全面
# 总的概率结合自身的记牌系统来？
# 对于跳转，推荐算法在每一步总能算出最优的走法。
# 概率上的推测需要？

